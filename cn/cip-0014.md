| cip  | title                             | author | status |
| ---- | --------------------------------- | ------ | ------ |
| 0014 | 用户利用钱包App进行加密通讯的规范 |        | 草案   |

## 概述

CoinEx Chain上的交易都可以附加Memo，这些Memo中可以附加任何信息。理论上讲，链上的两个用户相互之间可以通过在彼此转账的交易的Memo中附加聊天信息，来实现彼此沟通。例如，用户A拥有某个别名或者Token，用户B希望同A洽谈，是否可以把别名或Token转让给B。

但是，由于链上的信息都是公开的，Memo中写的所有内容别人都可以看到。这里存在着泄漏隐私的可能性。

## 背景

CoinEx Chain上的用户都在链上保存着公钥，且自己在钱包里保存着私钥。用户A和B可以利用ECDH来生成同样的一个用于对称加密的密钥，然后使用这个密钥来彼此通讯。

在比特币的libsecp256k1函数库中，secp256k1_ecdh函数可以使用A的私钥配B的公钥生成一个256位整数X，同时使用A的公钥配B的私钥生成完全相同的整数X。

## 目的

本文规范了如何利用ECDH机制所生成的256位的整数，来加密memo中保存的信息。

## 规范

对memo的明文，应当使用AES256-GCM对其进行加密，加密中使用的key字节串长度是32，由上述的256位整数X按Little Endian的方式排列得来。加密后的密文字节串将被作为交易的memo中。

加密解密的具体实现，其行为应该同下面的Golang代码相同：

```go
// AesGcmEncrypt takes an encryption key and a plaintext string and encrypts it with AES256 in GCM mode, 
// which provides authenticated encryption. Returns the ciphertext and the used nonce.
// len(key) must be 32, to select AES256
func AesGcmEncrypt(key []byte, plaintext string) (ciphertext, nonce []byte) {
	plaintextBytes := []byte(plaintext)

	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err.Error())
	}

	// Never use more than 2^32 random nonces with a given key because of the risk of a repeat.
	nonce = make([]byte, 12)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		panic(err.Error())
	}

	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		panic(err.Error())
	}

	ciphertext = aesgcm.Seal(nil, nonce, plaintextBytes, nil)
	fmt.Printf("Ciphertext: %x\n", ciphertext)
	fmt.Printf("Nonce: %x\n", nonce)

	return
}

// AesGcmDecrypt takes an decryption key, a ciphertext and the corresponding nonce, 
// and decrypts it with AES256 in GCM mode. Returns the plaintext string.
// len(key) must be 32, to select AES256
func AesGcmDecrypt(key, ciphertext, nonce []byte) (plaintext string) {
	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err.Error())
	}

	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		panic(err.Error())
	}

	plaintextBytes, err := aesgcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		panic(err.Error())
	}

	plaintext = string(plaintextBytes)
	fmt.Printf("%s\n", plaintext)

	return
}
```

