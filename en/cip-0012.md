| cip  | title                                                        | author | status |
| ---- | ------------------------------------------------------------ | ------ | ------ |
| 0012 | Communication through QR Code between cold wallet and hot wallet |        | Draft  |

## Abstract

A cell phone with all its wireless connections turned off, can be used as a cold wallet for storing secret key and signing transactions. The communication between this cold wallet and a hot wallet which have wireless connection, is totally through QR Code.

## Background

When a private keys is stored on a device with internet connections, it is vulnerable to hackers. So, to store a large amount of digital assets, the cold wallet is a better solution. Using an old cell phone as cold wallet is a cheap solution, and it can also prevent "supply chain attack".

## Motivation

This CIP specifies the text format sent through QR Code. Thus the cold wallets and hot wallets from different vendors can talk to each other.

## Sepcification

The text sent through QR Code must be json string, which is described as follow:

#### From hot wallet to cold wallet

The json string sent from hot wallet to cold wallet, is a map, i.e., key-value pairs, and the keys' meaning are:

1. tx: a transaction to be signed, it is a map, whose content is decided by tx_type.
2. tx_type: the type of the transaction; its valid values include "transfer", "delegate", "undelegate", "redelegate", "withdraw_delegator_reward" and "raw".
3. account_number：the account number of the account which will sign this transaction. 
4. sequence： the sequence of the account which will sign this transaction. 
5. fee：the gas fee which will pay to the validators
6. gas：the gas number of this transaction
7. memo：memo
8. chain_id：the chain id, for example, “coinexdex”。

When `tx_type` is “transfer”, the value of `tx` should be a map as following：

1. amount：the amount to be transferred,  note 100000000 (1e8) denotes one coin here.
2. denom：the symbol of the token which will be transferred.
3. from：the source account's bech32 address.
4. to：the target account's bech32 address.

When `tx_type` is “withdraw_delegator_reward”, the value of `tx` should be a map as following:

1. delegator：the delegator's bech32 address
2. validator：the validator bech32 address (starts with coinexvaloper1)

When `tx_type` is “delegate” or "undelegate", the value of `tx` should be a map as following:

1. amount：the amount of CET to be delegated or undelegated
2. delegator：the delegator's bech32 address
3. validator：the validator bech32 address (starts with coinexvaloper1)

When `tx_type` is “redelegate”, the value of `tx` should be a map as following:

1. amount：the amount of CET to be delegated or undelegated
2. delegator：the delegator's bech32 address
3. validator_src：the address of the validator whose voting power will be decreased.
4. validator_dst：the address of the validator whose voting power will be increased.

When `tx_type` is “vote”, the value of `tx` should be a map as following:

1. proposal_id：the proposal's id
2. voter：the bech32 address of the voter
3. option：an integer. 1 for yes, 2 for abstain, 3 for no, and 4 for veto.

When the `tx_type` is "raw", the value of `tx` must be a json string which is generated by the GetSignBytes function of sdk.Msg.

The json string showed by a hot wallet must have no white spaces (space, return or tab).

Following is an example ( returns and tabs are added for easy reading):

```json
{
	"tx_type":"transfer",
	"tx":{
		"amount":1000000000,
		"denom":"CET",
		"from":"coinex1...",
		"to":"coinex1..."
	},
	"account_number":104,
	"sequence":185,
	"fee":2000000,
	"gas":100000,
	"memo":""
}
```

#### From cold wallet to hot wallet

The text sent through QR Code from cold wallet to hot wallet, can be one of following two formats:

1. A bech32 address starting with "coinex1"
2. A Json map whose format must be the same as the json map generated by the command `cetcli tx sign --offline`

The command `cetcli tx sign --offline` generates following informations:

1. fee：the transaction's gas fee (copied from the json string sent from the hot wallet)
	1. amount：
		1. amount：an integer showing the gas fee's amount
		2. denom：can only be "cet"
	2. gas：an integer showing the gas number
2. memo：copied from the json string sent from the hot wallet
3. msg：A json array with only one entry, which must be the json map returned by the GetSignBytes function of sdk.Msg.
4. signatures：
	1. pub_key：
		1. type：can only be "tendermint/PubKeySecp256k1"
		2. value：a base64-encoded byte slice
	2. signature：a base64-encoded byte slice

The json string showed by a hot wallet must have no white spaces (space, return or tab).

Following is an example ( returns and tabs are added for easy reading):


```json
{
	"fee":{"amount":[{"amount":"2000000","denom":"cet"}],
		"gas":"100000"},
	"memo":"",
	"msg":[
		{"type":"bankx/MsgSend",
		"value":{"amount":[{"amount":"1000000000","denom":"cet"}],
			"from_address":"coinex1...",
			"to_address":"coinex1...",
			"unlock_time":"0"
			}
		}
	],
	"signatures":[
		{"pub_key":{
			"type":"tendermint/PubKeySecp256k1",
			"value":"AoPytzskEFDgcyo83kMnZLDhyug8fWLpSuKT29Y1w5c8"
			},
		"signature":"……"
		}
	]
}
```

In this example, the array of "msg" has only one entry, whose format is described as following：

1. type：the Msg Type, "bankx/MsgSend" for sending coins.
2. value：
  1. amount：
     1. amount：an integer showing the transferred amount
     2. denom：the symbol of the sent token.
  2. from_address：the payer's bech32 address
  3. to_address：the payee's bech32 address
  4. unlock_time： it is 0 because locked send is not used here.

